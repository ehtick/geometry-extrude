<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/tweakpane@3.0.5/dist/tweakpane.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/petite-vue@0.3.0/dist/petite-vue.iife.js"></script>
    <script src="../dist/geometry-extrude.js"></script>
    <script src="./lib/claygl.js"></script>
</head>
<body>
    <style>
        body {
            margin: 0;
        }
        .container {
            display: flex;
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
        }
        .sketch, .preview {
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.25);
            border-radius: 20px;
        }
        .sketch {
            flex: 1;
            margin: 20px;
            background: #2c3e50;
            position: relative;
        }
        .sketch button {
            position: absolute;
            bottom: 10px;
            left: 50%;
            width: 120px;
            margin-left: -60px;

            border: none;
            background: #fff;
            font-size: 18px;
            line-height: 30px;
            border-radius: 5px;
            cursor: pointer;
        }
        .preview {
            flex: 2;
            margin: 20px;
            overflow: hidden;
        }
        .config {
            flex: 0.5;
            margin: 20px;
        }
    </style>
    <div class="container" v-scope>
        <div class="sketch">
            <canvas @click="addPoint" style="width: 100%;height: 100%;"></canvas>
            <button @click="toggleDraw">{{ drawing ? 'Close' : 'Start Draw'}}</button>
        </div>
        <div class="preview"></div>
        <div class="config"></div>
    </div>

    <script>

        const sketchCanvas = document.querySelector('.sketch canvas');
        const sketchCtx = sketchCanvas.getContext('2d');
        const dpr = window.devicePixelRatio;
        resizeSketchPad()
        sketchCtx.scale(dpr, dpr);

        function resizeRenderer(app) {
            app.renderer.canvas.style.width = '100%';
            app.renderer.canvas.style.height = '100%';
        }
        function resizeSketchPad() {
            sketchCanvas.width = sketchCanvas.clientWidth * dpr;
            sketchCanvas.height = sketchCanvas.clientHeight * dpr;
        }

        function redrawSketch(close) {
            const width = sketchCanvas.clientWidth;
            const height = sketchCanvas.clientHeight;
            sketchCtx.clearRect(0, 0, width, height);
            const pointSize = 10;
            sketchCtx.strokeStyle = '#ddd';
            sketchCtx.fillStyle = '#ddd';
            sketchCtx.lineWidth = 2;

            sketchCtx.beginPath();
            config.points.forEach(pt => {
                sketchCtx.lineTo(pt[0] * width, pt[1] * height);
            });

            if (close) {
                sketchCtx.closePath();
            }
            sketchCtx.stroke();

            config.points.forEach(pt => {
                sketchCtx.beginPath();
                sketchCtx.rect(pt[0] * width - pointSize / 2, pt[1] * height - pointSize / 2, pointSize, pointSize);
                sketchCtx.fill();
            });
        }

        PetiteVue.createApp({
            drawing: false,

            toggleDraw() {
                this.drawing ? this.endDraw() : this.startDraw();
            },

            startDraw() {
                this.drawing = true;
                config.points = [];
                redrawSketch();
            },

            addPoint(e) {
                if (!this.drawing) {
                    this.startDraw();
                }
                const width = sketchCanvas.clientWidth;
                const height = sketchCanvas.clientHeight;
                const x = e.offsetX;
                const y = e.offsetY;
                const first = config.points[0]
                if (first && Math.sqrt((first[0] * width - x) * (first[0] * width - x) + (first[1] * height - y) * (first[1] * height - y)) < 10) {
                    // Try auto close
                    this.endDraw();
                }
                else {
                    config.points.push([x / width, y / height]);
                    redrawSketch();
                }
            },

            endDraw() {
                this.drawing = false;

                redrawSketch(true);

                app.methods.updateExtrudeGeometry();
                app.render();
            }
        }).mount();

        const config = {
            points: [
                [0.2, 0.2],
                [0.8, 0.2],
                [0.8, 0.8],
                [0.2, 0.8]
            ],
            depth: 2,
            bevelSize: 0.5,
            bevelSegments: 5
        };
        try {
            Object.assign(config, JSON.parse(localStorage.getItem('config')));
        }
        catch (e) {
        }

        const app = clay.application.create('.preview', {
            autoRender: false,

            graphic: {
                // shadow: true,
                // Enable tonemapping
                tonemapping: true,
                // Use linear color space instead of default sRGB.
                linear: true
            },

            init(app) {
                resizeRenderer(app);

                this._camera = app.createCamera([0, 0, 20], [0, 0, 0]);

                app.createDirectionalLight([-1, -2, -1], '#aaa');
                const geometry = new clay.Geometry();
                const mesh = app.createMesh(geometry, {});
                mesh.material.set('lineWidth', 1);

                this._mesh = mesh;

                this._control = new clay.plugin.OrbitControl({
                    target: this._camera,
                    domElement: app.container,
                    timeline: app.timeline,
                    rotateSensitivity: 2
                });

                this._control.on('update', function () {
                    app.render();
                });

                app.methods.updateExtrudeGeometry();

                return app.createAmbientCubemapLight('./asset/gray-background-with-dirlight.hdr', 1, 0.3).then(function (result) {
                    const skybox = new clay.plugin.Skybox({
                        scene: app.scene,
                        environmentMap: result.specular.cubemap
                    });
                    // Use high lod to show the `rough` skybox
                    skybox.material.set('lod', 4);
                    app.render();
                });
            },

            loop() {},

            methods: {

                updateExtrudeGeometry() {
                    // Scale and position points
                    let minX = Infinity;
                    let minY = Infinity;
                    let maxX = -Infinity;
                    let maxY = -Infinity;

                    config.points.forEach(pt => {
                        minX = Math.min(pt[0], minX);
                        minY = Math.min(pt[1], minY);
                        maxX = Math.max(pt[0], maxX);
                        maxY = Math.max(pt[1], maxY);
                    });

                    const width = maxX - minX;
                    const height = maxY - minY;

                    const scale = 10 / width;
                    const targetHeight = height * scale;
                    const translateX = -5 - minX * scale;
                    const translateY = -targetHeight / 2 - minY * scale;

                    const points = config.points.map(pt => [
                        pt[0] * scale + translateX,
                        pt[1] * scale + translateY,
                    ]);
                    const result = geometryExtrude.extrudePolygon([
                        [points]
                    ], {
                        depth: config.depth,
                        bevelSize: config.bevelSize,
                        bevelSegments: config.bevelSegments
                    });
                    const geometry = this._mesh.geometry;
                    geometry.attributes.position.value = result.position;
                    geometry.indices = result.indices;
                    geometry.generateVertexNormals();
                    geometry.generateBarycentric();
                    geometry.updateBoundingBox();
                    geometry.dirty();
                    this._mesh.position.z = -config.depth / 2;

                    localStorage.setItem('config', JSON.stringify(config));
                }
            }
        });

        window.onresize = () => {
            app.resize();
            resizeRenderer(app);
            resizeSketchPad();
            redrawSketch(true);
        }


        // Init tweakpane
        const pane = new Tweakpane.Pane({
            container: document.querySelector('.config')
        });
        pane.addInput(config, 'depth', {
            min: 0,
            max: 20
        });
        pane.addInput(config, 'bevelSize', {
            min: 0,
            max: 10
        });
        pane.addInput(config, 'bevelSegments', {
            min: 0,
            max: 20
        });
        pane.on('change', (ev) => {
            app.methods.updateExtrudeGeometry();
            app.render();
        });

        redrawSketch(true);

    </script>
</body>
</html>